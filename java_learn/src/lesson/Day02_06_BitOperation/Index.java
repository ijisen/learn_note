package lesson.Day02_06_BitOperation;

/**
 * 位运算
 * &  按位与：对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。
 * |  按位或：对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。
 * ~  按位取反 0->1;1->0;包括符号位
 * ^  按位异或 a^b  a !== b
 * >>  右位移 8<<3  8/2^(3-1)/2^(2-1)/2^(1-1) = 1
 * >>> 无符号右位移
 * <<  左位移 8<<3  8*2^(3-1)*2^(2-1)*2^(1-1) = 64
 * */


/**
 * 计算逻辑
 * 1、二进制的最高位是符号位，0表示正数，1表示复数
 * 2、正数的原码、反码、补码都一样（三码合一）
 * 3、负数的反码 = 源码符号位不变，其它取反（0->1,1->0）;
 * ==> 10000000 00000000 00000000 00000000 -> 11111111 11111111 11111111 11111111
 * 4、负数的补码=反码+1； 反码=补码-1
 * 5、0的补码、反码都是0
 * 6、java没有无符号数，换言之，java中的数都是有符号的
 * 7、在计算时，都是以补码的方式计算的
 * 8、查看运算结果时，都是查看的源码
 *
 * */
public class Index {
    public static void main(String[] arg) {
        // 原码 =》 反码 =》 补码
        // 按位与
        // 计算是以补码计算
        // 输出是输出原码
        // 正数的原码 反码 补码都是一样的
        // 1的补码 =》 00000000 00000000 00000000 00000001
        // 2的补码 =》 00000000 00000000 00000000 00000010

        // 1的补码  =》 00000000 00000000 00000000 00000001
        // 2的补码  =》 00000000 00000000 00000000 00000010
        // 计算补码 =》 00000000 00000000 00000000 00000000
        System.out.println(1&2); // 0


        // 负数的反码 = 源码（0->1; 1->0）
        // 负数的补码 = 反码 + 1
        // -3是负数，且为int类型（4个子节）
        // -3的原码 =》10000000 00000000 00000000 00000011
        // -3的反码 =》11111111 11111111 11111111 11111100
        // -3的补码 =》11111111 11111111 11111111 11111101

        // -2是负数，且为int类型（4个子节）
        // -2的原码 =》10000000 00000000 00000000 00000010
        // -2的反码 =》11111111 11111111 11111111 11111101
        // -2的补码 =》11111111 11111111 11111111 11111110

        // 按位与 1 -> 1;
        // -2的补码    =》11111111 11111111 11111111 11111110
        // -3的补码    =》11111111 11111111 11111111 11111101
        // 11111111 11111111 11111111 11111100 =》 按位与补码
        // 11111111 11111111 11111111 11111011 =》反码 = 补码 -1
        // 10000000 00000000 00000000 00000100 =》 原码 =》 0->1；1->0

        System.out.println(-3&-2); //-4

        //8421
        // 10000000 00000000 00000000 00000110 =》 -6的原码
        // 11111111 11111111 11111111 11111001 =》 -6的反码 =》 0->1;1->0
        // 11111111 11111111 11111111 11111010 =》 -6的补码： 反码+1

        // 10000000 00000000 00000000 00000100 =》 -4的原码
        // 11111111 11111111 11111111 11111011 =》 -4的反码
        // 11111111 11111111 11111111 11111100 =》 -4的补码

        // 按位与 1 0
        // 11111111 11111111 11111111 11111010 =》 -6的补码： 反码+1
        // 11111111 11111111 11111111 11111100 =》 -4的补码
        // 11111111 11111111 11111111 11111000 =》 计算后的补码
        // 11111111 11111111 11111111 11110111 =》 计算后的反码 补码-1
        // 10000000 00000000 00000000 00001000 =》 计算后的原码 =》 0->1;1->0

        System.out.println(-6&-4); //-8

        System.out.println(~2); //-3


        // 10000000 00000000 00000000 00010100 => -20的原码
        // 11111111 11111111 11111111 11101011 => -20的反码
        // 11111111 11111111 11111111 11101100 => -20的补码

        // 10000000 00000000 00000000 00001000 => -8的原码
        // 11111111 11111111 11111111 11110111 => -8的反码
        // 11111111 11111111 11111111 11111000 => -8的补码

        // 11111111 11111111 11111111 11111000 => -20的补码
        // 11111111 11111111 11111111 11101100 => -8的补码
        // 11111111 11111111 11111111 11101000 => 补码计算
        // 11111111 11111111 11111111 11100111 => 补码转反码 补码-1
        // 10000000 00000000 00000000 00011000 => 反码转原码
        System.out.println(-20&-8); // -24


        // 10000000 00000000 00000000 00010100 => -20的原码
        // 11111111 11111111 11111111 11101011 => -20的反码
        // 11111111 11111111 11111111 11101100 => -20的补码

        // 00000000 00000000 00000000 00001000 => 8的原码&反码&补码

        // 11111111 11111111 11111111 11101100 => -20的补码
        // 00000000 00000000 00000000 00001000 => 8补码
        // 00000000 00000000 00000000 00001000 => 补码计算（正数，三码合一）
        System.out.println(-20&8); // 8

    }
}
